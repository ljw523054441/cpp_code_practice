## 指针(pointer)简介
指针是一个值为内存地址的<font color = red>变量</font>（或数据对象）
指针就是一个变量，是保存别的变量内存地址的变量

int year;
year = 2016;//假设此时它的内存地址是0028FF44（通常用16进制表示内存地址）

int *ptr_year;//整型指针变量
ptr_year = &year;//&是取址符

通过指针是间接获取数据，通过变量名是直接获取数据，使用变量名来获取数据的效率最高
指针只能通过上面这种取地址的方法来赋值

## 声明及初始化指针变量
基本用法：
数据类型* 指针变量名；
例如
```c++
int* ptr_num;
char* ptr_name;
float* money_ptr;
double* p_price;
```
注意：
```
- int* p的写法偏向于地址，即p就是一个地址变量，表示一个十六进制地址
- int *p的写法偏向于值，*p是一个整型变量，能够表示一个整型值
建议两者相结合进行理解
声明中的*号和使用中的*号含义完全不同
```
## 取地址符&
```c++
int num = 1024;
int* ptr_num;//int*类型的变量 ptr_num
//取num变量的地址赋值给ptr_num,ptr_num这个变量指向了num
//*出现在定义的语句，表示是指针类型
ptr_num = &num;
```
## 间接运算符
```c++
int num = 1024;
int* ptr_num;
ptr_num = &num;

*ptr_num = 1111;//根据地址，找到空间值，并重新赋了一个新值1111
//上面一行语句就相当于语句 num = 1111；
//*出现在非定义语句，表示取值，根据ptr_num这个地址，找到真实的空间值
```
取地址的好处是，可以直接找到这个对象并进行修改

## 指针使用示例
```c++
#include <iostream>
using namespace std;

int main()
{
    double num = 1024.5;
    //声明一个指针，指向num变量
    double* ptr_num = &num;
    cout << "ptr_num的值：" << ptr_num << endl;
    cout << "ptr_num指向空间的值是：" << *ptr_num << endl;
}
```
## 空指针(null pointer)
空指针不指向任何对象，在试图使用一个指针之前可以首先检查是否为空
### 空指针的用法
```c++
int *ptr1 = nullptr;//等价于int *ptr1 = 0；
int *ptr2 = 0;//直接将ptr2初始化为字面常量0
```
**在声明指针的时候，如果没有初值，那么一定要给它一个初值nullptr，这样就不会造成野指针的错误**
**强烈建议初始化所有指针，哪怕给个0，并在可能的情况下，尽量等定义了对象之后再定义指向它的指针**

如果要是用NULL，就需要包含cstdlib这个头文件
```c++
int *ptr3 = NULL;//等价于int *ptr3=0；
```
## void*指针
一种特殊的指针类型，可以存放任意对象的地址
```c++
double objNum = 3.14;
double *ptr_obj = &objNum;

//cout << boolalpha;加上这句可以让输出的数值转换成true or false
void *vptr_obj = &objNum;//可以指向任意类型
cout << (ptr_obj == vptr_obj) << endl;
```
上面几行代码，输出是1，表示两者相等

注意：
- `void*指针存放一个内存地址，地址指向的内容是什么类型不能确定,所以在通过void*指针来修改变量的值时，编译器是不允许这样做的`
- `void*类型指针一般用来：拿来和别的指针比较;作为函数的输入和输出;赋值给另一个void*指针`

## 指针小结
- 指针同样是一个变量，只不过该变量中存储的是另一个对象的内存地址
- 如果一个变量存储另一个对象的地址，则称该变量指向这个对象
- 指针变量可以赋值，但一定使用&来赋值的，指针的指向在程序执行中可以改变
  - 指针p在执行中某时刻指向变量x，在另一时刻也可以指向变量y
- 指针可以指任何基本数据类型、数组和其他所有高级数据结构的地址（把指针放到数组中，原本占很大空间的数组，可以变得所占空间很小）

## 引用(reference)
给对象起了个另外一个名字，引用即别名
```c++
int int_value = 1024;
int& refValue = int_value;
//refValue指向int_value， 是int_value的另一个名字

int& refValue2;
//这样写是错误的，因为引用是必须要有值的，引用的底层也是通过指针来实现的
```

注意：
- 引用并非对象，只是为一个已经存在的对象起的别名
- 引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起，例如int& ref_value = 10；是错误的
- 引用必须初始化，所以使用引用之前不需要测试其有效性，因此使用引用可能会比使用指针效率高
- **指向常量的引用是非法的**，即double& ref = 100，是非法的，因为double&这样的引用是指向变量的，但是const double& ref = 100;是正确的，表示是一个常量的引用

## 指针和引用
### 两者之间的关系
引用对指针进行了简单封装，底层仍然是指针
获取地址时，编译器会进行内部转换
```c++
int num =108;
int& rel_num =num;
rel_num = 118;
cout << &num << '\t' << &rel_num << endl;
```
&num与&rel_num结果是相同的
这段代码在编译器内部的运行机制其实是
```c++
int num = 108;
int* rel_num = &num;
*rel_num = 118;
cout << &num << '\t' << rel_num << endl;
```

## 指针与数组
数组：
- 存储在一块连续的内存空间中
- 数组名就是这块连续的内存空间的首地址

```c++
double score[5] = {98,87,65,43,76};
double* ptr_score;
ptr_score = &score[0];
//ptr_score = score;
```

|表格| | |
-|-|-
0x6afed0|98|score[0]
0x6afed8|87|score[1]
0x6afee0|65|score[2]
0x6afee8|43|score[3]
0x6afef0|76|score[4]

```c++
double score[]{11,22,33,44,55};
double * ptr_score = score;
cout << ptr_score[3] << endl;
//输出结果为44
//当指针指向一个数组时，其就可以当一个数组来访问了


//例如
int num =108;
int& rel_num =num;
rel_num = 118;
cout << &num << '\t' << &rel_num << endl;

double score[]{11,22,33,44,55};
double* ptr_score = score;//数组名score就是数组的首地址，不用取址符&

cout << sizeof(score) << '\t' << sizeof(ptr_score) << endl;
//数组的数据类型是数据类型[],例如double[]，因此这里sizeof(score)是40，score[5]*8
```

## 指针运算
### 指针的算数运算
指针的递增和递减（++，--）
指针的运算一般把它理解成指针的平移
```c++
int i;
double score[5]{98,87,65,43,76};
double * ptr_score;
ptr_score = score;//赋值数组的首地址
for(i = 0;i < 5;i++)
{
    cout << *ptr_score++ << endl;
}
```
注意：
一个类型为T的指针的移动，以sizeof(T)为移动单位
| | | |
|-|-|-|
|0x6afed0|98|score[0]|
|0x6afed8|87|score[1]|
|0x6afee0|65|score[2]|
|0x6afee8|43|score[3]|
|0x6afef0|76|score[4]|
这里就是移动一个浮点数所占的8个字节

注意：
**不能让指针随便++--，因为可能会越界，但是不会报错，例如ptr_score - 9,可能就会指到这个数组之外**


## 数组与指针小结
- 数组名就是这块连续内存单元的首地址
  - int num[50];//num是数组名，也可以理解成数组的首地址
  - num的值与&num[0]的值是相同的
  - 数组第i个元素(从0开始)可以表示为
    - 第i个元素的地址：&num[i]或num + i
    - 第i个元素的值：num[i]或*(num + i)同样尝试*++ptr_num//注意：数组名是不能参与++--运算的，只有指针可以
  - 为指向数组的指针赋值
    - int * ptr_num = num;或int * ptr_num = &num[0];
  - 指针变量可以指向数组元素
    - int * ptr_num = &num[4];或int * ptr_num = num + 4;

## 动态分配内存
### 使用new分配内存
- 指针真正的用武之地：在运行阶段分配未命名的内存以存储值，在运行到这句话的时候再分配内存，而不是刚开始的时候就分配
- 在此情况下，只能通过指针来访问内存

### 使用delete释放内存
- 与new配对使用
- 不要释放已经释放的内存
- 不能释放声明变量分配的内存

```c++
//1.在运行阶段为一个int值分配未命名的内存
//2.使用指针来访问（指向）这个值（从右向左）
int * ptr_int = new int;

delete ptr_int;//释放由new分配的内存
```

new int 是分配一块内存，空间是一个整型空间
然后把这块内存空间的地址赋值给左侧，此时ptr_int这个变量指向了这个新的内存空间

delete释放了这部分内存

int num[5];是在编译时就已经分配了5个整型空间，这5个空间也不能销毁，不能修改，直到程序结束
int * nums = new int[5];是整个程序运行到这句话的时候，编译器才给了它5个整型空间，然后把这个空间的地址赋值给nums，nums指向了一个新空间

注意：
- 不要创建两个指向同一内存块的指针，有可能误删除两次
```c++
int * ptr = new int;
int * ptr1 = ptr;
delete ptr;
delete ptr1;
```

## 动态分配的数组
使用new创建动态分配的数组
`int * intArray = new int[10];// intArray 指针指向了一块连续的内存空间`
  - new 运算符返回第一个元素的地址

使用delete[]释放内存
`delete[] intArray;`
  - []释放整个数组

## 补充：程序的内存分配
栈区（stack）
  - 由编译器自动分配释放，一般存放函数的参数值、局部变量的值等
  - 操作方式类似数据结构中的栈，先进后出

堆区（heap）
  - 一般由程序员分配释放，若程序不释放，程序结束时可能由操作系统回收
  - 注意：与数据结构中的堆是两回事，分配方式类似链表

全局区（静态区-static）
  - 全局变量和静态变量是存储在一起的
  - 程序结束后由系统释放

文字常量区
  - 常量字符串就放在这里，程序结束由系统释放

程序代码区
  - 存放函数体的二进制代码

```c++
int num1 = 0;//全局初始化区
int * ptr1;//全局未初始化区
int main()
{
    //栈区
    int num2
    //栈区
    char str[] = "ljiawei";
    //栈区
    char * ptr2;
    //lijiawei以及\0在常量区，ptr3在栈区
    char * ptr3 = "lijiawei"
    //全局（静态）初始化区
    static int num3 = 1024;
    //分配的内存在堆区
    ptr1 = new int[10];
    ptr2 = new char[20];
    //注意：ptr1和ptr2本身是在栈区中的
}
```

## 数组与指针示例

### 指针实现元素收尾交换
```c++
    int * ptr_start = arrays;//指向第一个元素
    int * ptr_end = arrays + 5;//指向最后一个元素

    int temp;

    while (ptr_start <= ptr_end)
    {
        temp = *ptr_start;
        *ptr_start = *ptr_end;
        *ptr_end = temp;
        ptr_start++;
        ptr_end--;
    }
    for (int i = 0; i < 6; i++)
    {
        cout << arrays[i] << endl;
    }
```

### 二维数组和指针
| |0|1|2|3|4|
|-|-|-|-|-|-|
|0|15|25|35|45|55|
|1|65|75|85|95|105|
|2|115|125|135|145|155|
对于三行五列的二维数组
- 首地址：&a[0][0]
- 使用指针访问二维数组中的元素
  - *(a[1]+2)
  - *((a+1)+2)

使用指针创建二维数组
```c++
int * p = new int[10]//这是创建一维数组的方式
//使用指针创建二维数组
int (*p2)[3] = new int[5][3];
//把二维数组其中的一维降成一个一维数组指针
p2[3][2] = 998;//二维数组赋值

for(int i = 0; i<5;i++)
{
    for(int j = 0; j<3;j++)
    {
        cout << *(*(p2+i)+j) << ',';//用指针的方式访问数组的值
    }
    cout << endl;
}
```
也可以是
```c++
int **a = new int*[2];//声明了一个二维数组，它有两列，行数还不确定
for(int i = 0;i<2;i++)
{
    a[i] = new int[5]//确定其列数是5
}
```

## 总结
- 指针是一个变量，存储另一个变量（对象）的内存地址
- 指针的声明由基本类型、星号和变量名组成
- 为指针赋值，赋值运算符右侧必须是一个地址
  - 如果是普通变量需要在前面加一个取地址运算符&
  - 如果是另个指针变量或者是一个数组，不需要加&运算符
- 运算符*用于返回指针指向的内存地址中存储的值
- 使用指针访问一维数组和二维数组的元素

- 指针支持运算，但是只是++或者--，实际上是变量存储地址的移动


## 制作小游戏练习
### 需求
- 使用控制台编写一个小游戏分别实现以下基础功能：
  - 新增数据
  - 修改数据
  - 查询数据
  - 删除数据
- 游戏规则
  - 进行78个月
  - 安排每月行程