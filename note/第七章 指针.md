## 指针(pointer)简介
指针是一个值为内存地址的<font color = red>变量</font>（或数据对象）
指针就是一个变量，是保存别的变量内存地址的变量

int year;
year = 2016;//假设此时它的内存地址是0028FF44（通常用16进制表示内存地址）

int *ptr_year;//整型指针变量
ptr_year = &year;//&是取址符

通过指针是间接获取数据，通过变量名是直接获取数据，使用变量名来获取数据的效率最高
指针只能通过上面这种取地址的方法来赋值

## 声明及初始化指针变量
基本用法：
数据类型* 指针变量名；
例如
```c++
int* ptr_num;
char* ptr_name;
float* money_ptr;
double* p_price;
```
注意：
```
- int* p的写法偏向于地址，即p就是一个地址变量，表示一个十六进制地址
- int *p的写法偏向于值，*p是一个整型变量，能够表示一个整型值
建议两者相结合进行理解
声明中的*号和使用中的*号含义完全不同
```
## 取地址符&
```c++
int num = 1024;
int* ptr_num;//int*类型的变量 ptr_num
//取num变量的地址赋值给ptr_num,ptr_num这个变量指向了num
//*出现在定义的语句，表示是指针类型
ptr_num = &num;
```
## 间接运算符
```c++
int num = 1024;
int* ptr_num;
ptr_num = &num;

*ptr_num = 1111;//根据地址，找到空间值，并重新赋了一个新值1111
//上面一行语句就相当于语句 num = 1111；
//*出现在非定义语句，表示取值，根据ptr_num这个地址，找到真实的空间值
```
取地址的好处是，可以直接找到这个对象并进行修改

## 指针使用示例
```c++
#include <iostream>
using namespace std;

int main()
{
    double num = 1024.5;
    //声明一个指针，指向num变量
    double* ptr_num = &num;
    cout << "ptr_num的值：" << ptr_num << endl;
    cout << "ptr_num指向空间的值是：" << *ptr_num << endl;
}
```
## 空指针(null pointer)
空指针不指向任何对象，在试图使用一个指针之前可以首先检查是否为空
### 空指针的用法
```c++
int *ptr1 = nullptr;//等价于int *ptr1 = 0；
int *ptr2 = 0;//直接将ptr2初始化为字面常量0
```
**在声明指针的时候，如果没有初值，那么一定要给它一个初值nullptr，这样就不会造成野指针的错误**
**强烈建议初始化所有指针，哪怕给个0，并在可能的情况下，尽量等定义了对象之后再定义指向它的指针**

如果要是用NULL，就需要包含cstdlib这个头文件
```c++
int *ptr3 = NULL;//等价于int *ptr3=0；
```
## void*指针
一种特殊的指针类型，可以存放任意对象的地址
```c++
double objNum = 3.14;
double *ptr_obj = &objNum;

//cout << boolalpha;加上这句可以让输出的数值转换成true or false
void *vptr_obj = &objNum;//可以指向任意类型
cout << (ptr_obj == vptr_obj) << endl;
```
上面几行代码，输出是1，表示两者相等

注意：
- `void*指针存放一个内存地址，地址指向的内容是什么类型不能确定,所以在通过void*指针来修改变量的值时，编译器是不允许这样做的`
- `void*类型指针一般用来：拿来和别的指针比较;作为函数的输入和输出;赋值给另一个void*指针`

## 指针小结
- 指针同样是一个变量，只不过该变量中存储的是另一个对象的内存地址
- 如果一个变量存储另一个对象的地址，则称该变量指向这个对象
- 指针变量可以赋值，但一定使用&来赋值的，指针的指向在程序执行中可以改变
  - 指针p在执行中某时刻指向变量x，在另一时刻也可以指向变量y
- 指针可以指任何基本数据类型、数组和其他所有高级数据结构的地址（把指针放到数组中，原本占很大空间的数组，可以变得所占空间很小）

## 引用(reference)
给对象起了个另外一个名字，引用即别名
```c++
int int_value = 1024;
int& refValue = int_value;
//refValue指向int_value， 是int_value的另一个名字

int& refValue2;
//这样写是错误的，因为引用是必须要有值的，引用的底层也是通过指针来实现的
```

注意：
- 引用并非对象，只是为一个已经存在的对象起的别名
- 引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起，例如int& ref_value = 10；是错误的
- 引用必须初始化，所以使用引用之前不需要测试其有效性，因此使用引用可能会比使用指针效率高
- **指向常量的引用是非法的**，即double& ref = 100，是非法的，因为double&这样的引用是指向变量的，但是const double& ref = 100;是正确的，表示是一个常量的引用

## 指针和引用
### 两者之间的关系
引用对指针进行了简单封装，底层仍然是指针
获取地址时，编译器会进行内部转换
```c++
int num =108;
int& rel_num =num;
rel_num = 118;
cout << &num << '\t' << &rel_num << endl;
```
&num与&rel_num结果是相同的
这段代码在编译器内部的运行机制其实是
```c++
int num = 108;
int* rel_num = &num;
*rel_num = 118;
cout << &num << '\t' << rel_num << endl;
```

## 指针与数组
数组：
- 存储在一块连续的内存空间中
- 数组名就是这块连续的内存空间的首地址

```c++
double score[5] = {98,87,65,43,76};
double* ptr_score;
ptr_score = &score[0];
//ptr_score = score;
```

|表格| | |
-|-|-
0x6afed0|98|score[0]
0x6afed8|87|score[1]
0x6afee0|65|score[2]
0x6afee8|43|score[3]
0x6afef0|76|score[4]

```c++
double score[]{11,22,33,44,55};
double * ptr_score = score;
cout << ptr_score[3] << endl;
//输出结果为44
//当指针指向一个数组时，其就可以当一个数组来访问了


//例如
int num =108;
int& rel_num =num;
rel_num = 118;
cout << &num << '\t' << &rel_num << endl;

double score[]{11,22,33,44,55};
double* ptr_score = score;//数组名score就是数组的首地址，不用取址符&

cout << sizeof(score) << '\t' << sizeof(ptr_score) << endl;
//数组的数据类型是数据类型[],例如double[]，因此这里sizeof(score)是40，score[5]*8
```

## 指针运算
### 指针的算数运算
指针的递增和递减（++，--）
指针的运算一般把它理解成指针的平移
```c++
int i;
double score[5]{98,87,65,43,76};
double * ptr_score;
ptr_score = score;//赋值数组的首地址
for(i = 0;i < 5;i++)
{
    cout << *ptr_score++ << endl;
}
```
注意：
一个类型为T的指针的移动，以sizeof(T)为移动单位
| | | |
|-|-|-|
|0x6afed0|98|score[0]|
|0x6afed8|87|score[1]|
|0x6afee0|65|score[2]|
|0x6afee8|43|score[3]|
|0x6afef0|76|score[4]|
这里就是移动一个浮点数所占的8个字节

注意：
**不能让指针随便++--，因为可能会越界，但是不会报错，例如ptr_score - 9,可能就会指到这个数组之外**


## 数组与指针小结
- 数组名就是这块连续内存单元的首地址
  - int num[50];//num是数组名，也可以理解成数组的首地址
  - num的值与&num[0]的值是相同的
  - 数组第i个元素(从0开始)可以表示为
    - 第i个元素的地址：&num[i]或num + i
    - 第i个元素的值：num[i]或*(num + i)同样尝试*++ptr_num//注意：数组名是不能参与++--运算的，只有指针可以
  - 为指向数组的指针赋值
    - int * ptr_num = num;或int * ptr_num = &num[0];
  - 指针变量可以指向数组元素
    - int * ptr_num = &num[4];或int * ptr_num = num + 4;