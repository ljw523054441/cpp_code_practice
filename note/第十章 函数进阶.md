## 内联函数（inline）
是C++为提高程序运行速度所做的一项改进
与常规函数的区别不在于编写方式，而在于被调用时的运行机制不同
- 在执行内联函数时，编译器使用函数代码替换函数调用
  - 在inline函数执行时，是把inline函数下的语句，直接替换到主函数当中对应的位置
  - 而常规函数执行时，是通过函数名（地址）在程序的堆内存中找到对应的函数的空间，在空间里真正运行该函数
- 内联函数的内存开销大

使用建议
- 如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很少一部分，这种情况不建议使用内联
- 如果**代码执行时间很短**，使用内联调用就可以节省大部分时间

使用内联函数
- 在函数声明前加关键字inline
- 在函数定义前加关键字inline

```c++
#include <iostream>
inline int pow(int,int);//可以在这里使用关键字inline，两个位置二选一即可
int main()
{
    int result1 = pow(5,3);
    int result2 = pow(4,5);
    int result3 = pow(3,4);
}

inline int pow(int num1,int num2)//可以在这里使用关键字inline，两个位置二选一即可
{
    int result = 1;
    for(int i = 0;i<num2;i++)
    {
        result *= num1;
    }
    return result;
}
```

## 引用回顾
引用(reference)
- 为对象起了另外一个名字（引用即别名）
```c++
int int_value = 1024;
//refValue指向int_value,是int_value的另外一个名字
int& refValue = int_value;

//错误：引用必须被初始化
int& refValue2;

//不可以直接引用常量
double& d = 12.3；
//如果一定要做的话
const double& d = 12.3；

//因为引用必须要初始化，所以我们在使用引用的时候，不需要测试其有效性
//所以我们使用引用的效率比指针要高一些

```

注意：
- 引用并非对象，只是为一个已经存在的对象起的别名
- 引用更接近const指针，一旦与某个变量关联起来，就将一直效忠于它
- 将引用变量用作参数时，函数将使用原始数据，而非副本
- 当数据所占内存比较大时，建议使用引用参数

实参通常是通过值传递给函数的，这意味着形参接收的只是发送给它们的值的副本，它们存储在函数的本地内存中。对形参值进行的任何更改都不会影响原始实参的值。

然而，有时候可能会希望一个函数能够改变正在调用中的函数（即调用它的函数）中的一个值，这可以通过引用传递的方式来完成。

我们知道，变量是可以保存数据的内存位置的名称。当使用变量时，实际上就是访问存储在分配给它的内存位置的数据。引用变量是变量的另一个别名，它没有自己的存储数据的内存位置，它访问的是另一个变量的内存位置。对引用变量作出的任何更改，实际上都是对它所引用的变量内存位置中存储数据的更改。

当使用引用变量作为形参时，它将变为实参列表中相应变量的别名，对形参进行的任何更改都将真正更改正在调用它的函数中的变量。当以这种方式将数据传递给形参时，该实参被称为按引用传递。

## 返回引用
函数返回引用类型
- 不要返回局部变量的引用
```c++
int& sum()//这是一个返回引用类型的函数
{
    int num =10;
    int& rNum = num;//注意rNum是在sum()函数中定义的，所以叫局部变量
    //rNum的生存周期只在sum()函数中
    return rNum;//返回了一个局部的引用类型的变量
}

//函数中的局部变量在函数结束后会被内存回收
//所谓的内存回收并不是把内存保存的数值清零
//而是指内存中你的程序申请的这块内存已经不是你的了
//当其他函数运行之后，这块被回收的内存可能被别的函数利用，它的值可能就不是当初的num局部变量了
//所以不要返回局部变量的引用

void test()
{
    int x = 1,y=2,z=3;
}

int main()
{
    int& result = sum();//result在这里实际上是引用了一个局部变量num
    test();//新的函数可能覆盖先前函数栈上的数据
    cout << "result = " << result << endl;
}
```
- 函数可以不返回值，默认返回传入的引用对象本身
```c++
int& sum(int& num1,int& num2)
{
    num1++;
    num2++;
    //没有返回值，默认返回最后一个修改更新的引用 参数
}
int main()
{
    int num1 =10,num2 = 15;
    int& result = sum(num1,num2);
    cout << "result = " << result << endl;
}
```
- 返回引用时，要求函数参数中包含被返回的引用对象
```c++
int& sum(int& num1,int& num2)
{
    return num1 + num2;
}
int main()
{
    int num1 =10,num2 = 15;
    int& result = sum(num1,num2);
    cout << "result = " << result << endl;
}

//此时会报错
```c++
int& sum(int& num)
{
    num++;
    return num;
}
int main()
{
    int num1 = 10;
    int& result = sum(num1);
    sum(num1) = 55;//c++允许给函数赋值，这里修改sum，相当于在修改result，因为result和sum是一个东西
    cout << "result = " << result << endl;
}
```
建议解决方案：
- 将返回类型修改为const int&
  const int& sum(int& num){...}
- const类型为不可修改的左值，sum(num) = 55将不合法
- 省略const会使函数的含义更加模糊，建议避免在设计函数中存在模糊的情况，因为模糊会增加犯错误的机会

## 使用引用参数小结
使用引用参数的一些指导原则
- 能够修改调用函数中的数据对象
- 数据对象较大时传递引用可以提高程序的运行效率
  - 函数中不需要修改传递的参数
    - 如果数据对象很小，建议按值传递
    - 传递数组只能使用指针，并使用const关键字
    - 较大的对象则使用const指针或引用，以提高程序的效率
  - 函数中需要修改传递的参数
    - 数据对象是基本类型或结构时，可以使用指针或引用（基本类型建议使用指针）
    - 数据对象是数组时只能使用指针
    - 数据对象是类对象时，建议要求使用引用


## 练习
需求
用函数实现游戏中的私聊
