## 内联函数（inline）
是C++为提高程序运行速度所做的一项改进
与常规函数的区别不在于编写方式，而在于被调用时的运行机制不同
- 在执行内联函数时，编译器使用函数代码替换函数调用
  - 在inline函数执行时，是把inline函数下的语句，直接替换到主函数当中对应的位置
  - 而常规函数执行时，是通过函数名（地址）在程序的堆内存中找到对应的函数的空间，在空间里真正运行该函数
- 内联函数的内存开销大

使用建议
- 如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很少一部分，这种情况不建议使用内联
- 如果**代码执行时间很短**，使用内联调用就可以节省大部分时间

使用内联函数
- 在函数声明前加关键字inline
- 在函数定义前加关键字inline

```c++
#include <iostream>
inline int pow(int,int);//可以在这里使用关键字inline，两个位置二选一即可
int main()
{
    int result1 = pow(5,3);
    int result2 = pow(4,5);
    int result3 = pow(3,4);
}

inline int pow(int num1,int num2)//可以在这里使用关键字inline，两个位置二选一即可
{
    int result = 1;
    for(int i = 0;i<num2;i++)
    {
        result *= num1;
    }
    return result;
}
```

## 引用回顾
引用(reference)
- 为对象起了另外一个名字（引用即别名）
```c++
int int_value = 1024;
//refValue指向int_value,是int_value的另外一个名字
int& refValue = int_value;

//错误：引用必须被初始化
int& refValue2;

//不可以直接引用常量
double& d = 12.3；
//如果一定要做的话
const double& d = 12.3；

//因为引用必须要初始化，所以我们在使用引用的时候，不需要测试其有效性
//所以我们使用引用的效率比指针要高一些

```

注意：
- 引用并非对象，只是为一个已经存在的对象起的别名
- 引用更接近const指针，一旦与某个变量关联起来，就将一直效忠于它
- 将引用变量用作参数时，函数将使用原始数据，而非副本
- 当数据所占内存比较大时，建议使用引用参数

实参通常是通过值传递给函数的，这意味着形参接收的只是发送给它们的值的副本，它们存储在函数的本地内存中。对形参值进行的任何更改都不会影响原始实参的值。

然而，有时候可能会希望一个函数能够改变正在调用中的函数（即调用它的函数）中的一个值，这可以通过引用传递的方式来完成。

我们知道，变量是可以保存数据的内存位置的名称。当使用变量时，实际上就是访问存储在分配给它的内存位置的数据。引用变量是变量的另一个别名，它没有自己的存储数据的内存位置，它访问的是另一个变量的内存位置。对引用变量作出的任何更改，实际上都是对它所引用的变量内存位置中存储数据的更改。

当使用引用变量作为形参时，它将变为实参列表中相应变量的别名，对形参进行的任何更改都将真正更改正在调用它的函数中的变量。当以这种方式将数据传递给形参时，该实参被称为按引用传递。

## 返回引用
函数返回引用类型
- 不要返回局部变量的引用
```c++
int& sum()//这是一个返回引用类型的函数
{
    int num =10;
    int& rNum = num;//注意rNum是在sum()函数中定义的，所以叫局部变量
    //rNum的生存周期只在sum()函数中
    return rNum;//返回了一个局部的引用类型的变量
}

//函数中的局部变量在函数结束后会被内存回收
//所谓的内存回收并不是把内存保存的数值清零
//而是指内存中你的程序申请的这块内存已经不是你的了
//当其他函数运行之后，这块被回收的内存可能被别的函数利用，它的值可能就不是当初的num局部变量了
//所以不要返回局部变量的引用

void test()
{
    int x = 1,y=2,z=3;
}

int main()
{
    int& result = sum();//result在这里实际上是引用了一个局部变量num
    test();//新的函数可能覆盖先前函数栈上的数据
    cout << "result = " << result << endl;
}
```
- 函数可以不返回值，默认返回传入的引用对象本身
```c++
int& sum(int& num1,int& num2)
{
    num1++;
    num2++;
    //没有返回值，默认返回最后一个修改更新的引用 参数
}
int main()
{
    int num1 =10,num2 = 15;
    int& result = sum(num1,num2);
    cout << "result = " << result << endl;
}
```
- 返回引用时，要求函数参数中包含被返回的引用对象
```c++
int& sum(int& num1,int& num2)
{
    return num1 + num2;
}
int main()
{
    int num1 =10,num2 = 15;
    int& result = sum(num1,num2);
    cout << "result = " << result << endl;
}

//此时会报错
```c++
int& sum(int& num)
{
    num++;
    return num;
}
int main()
{
    int num1 = 10;
    int& result = sum(num1);
    sum(num1) = 55;//c++允许给函数赋值，这里修改sum，相当于在修改result，因为result和sum是一个东西
    cout << "result = " << result << endl;
}
```
建议解决方案：
- 将返回类型修改为const int&
  const int& sum(int& num){...}
- const类型为不可修改的左值，sum(num) = 55将不合法
- 省略const会使函数的含义更加模糊，建议避免在设计函数中存在模糊的情况，因为模糊会增加犯错误的机会

## 使用引用参数小结
使用引用参数的一些指导原则
- 能够修改调用函数中的数据对象
- 数据对象较大时传递引用可以提高程序的运行效率
  - 函数中不需要修改传递的参数
    - 如果数据对象很小，建议按值传递
    - 传递数组只能使用指针，并使用const关键字
    - 较大的对象则使用const指针或引用，以提高程序的效率
  - 函数中需要修改传递的参数
    - 数据对象是基本类型或结构时，可以使用指针或引用（基本类型建议使用指针）
    - 数据对象是数组时只能使用指针
    - 数据对象是类对象时，建议要求使用引用


## 练习
需求
用函数实现游戏中的私聊


## 默认参数
参数是可以有默认值的
```c++
void sample(int = 10);

void sample(int num)
{
    cout << num << endl;
}

int main()
{
    sample();
    sample(123);
}
```
输出结果为10，123

注意：
- 默认值可以在函数原型或定义中给出，不能在这两个位置同时出现
- 对于带参数列表的函数，必须从右向左添加默认值
  - void test1(int a , int b = 5, int c = 10);//在调用test1(1)时,是使得a=1，在调用test1(1,2)时，时使得a = 1，b = 2 ，这时c = 10;
  - void test2(int a ,int b = 5 ,int c);//在调用test2(1)时出现错误，**所以默认参数后的参数也必须有默认值**
  - void test3(int a = 1,int b = 5,int c = 10);//在调用test3(),test3(1),test3(1,2)时都是正确的

## 函数重载(overloading)
指可以有多个同名的函数。
函数名相同，参数列表不同（特征标不同）。

重载——编译器在编译时，根据参数列表对函数进行重新命名
例如
```c++
void Swap(int a, int b)
//编译器编译时，将函数名重新命名为Swap_int_int

void Swap(float a, float b)
//编译器编译时，将函数名重新命名为Swap_float_float

void Swap(int& a, int& b)
//编译器编译时，将函数名重新命名为Swap_int_int,因为引用指向的还是原来的变量，所以没变跟第一种情况一样，这不能算是重载
//编译器把类型引用和类型本身视为同一个特征标
//在调用匹配函数的时候，不区分const和非const变量
```

### 练习-使用函数重载实现不同数据类型数组的排序


## 函数模板(Function Template)
所谓函数模板，实际上就是建立一个通用函数
- 函数定义时，不指定具体的数据类型（使用虚拟类型代替）
- 函数被调用时编译器根据实参反推数据类型-类型的参数化

```c++
//模板头与函数声明/定义永远是不可分割的整体！
template <typename 类型参数1，typename 类型参数2，...>
返回值类型 函数名（形参列表）{
    //在函数体中可以使用类型参数
}
```

```c++
//函数声明
template <typename T> void Swap(T&,T&);//虚拟类型T

/**
 * 使用模板技术实现变量交换值
 */
template <typename T> //模板头
void Swap(T &a, T &b)
{
    T temp = a;
    a = b;
    b = temp;
}
```

函数模板一般用于
- 写底层框架的时候