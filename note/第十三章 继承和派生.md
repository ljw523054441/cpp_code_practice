## 什么是继承和派生
在C++中，代码重用是通过“继承（inheritance）”机制实现的
- 所谓继承就是在一个已经存在的类的基础上，再建立一个新类
- 从已有的类派生出新的类，派生类就继承了原有类（基类）的特征，包括成员和方法

通过继承可以完成下面的一些功能：
- 可以在已有类的基础上添加新功能，如对于数组类，可以添加数学计算
- 可以给类添加数据成员，如对于字符串类，可以派生出一个类，并添加指定成员表示颜色
- 可以修改类方法的行为，如对于普通英雄类，可以派生出拥有更丰富技能的近战英雄类

注意：
- 继承机制只需要提供新特性，甚至不需要访问源码就可以派生出类
- 即，如果购买的类库只提供了类方法的头文件和编译后的代码，仍可以使用库中的类派生出新的类，而且可以在不公开实现的情况下将自己的类分发给其他人，同时允许他们在类中添加新特性。

## 示例
方案一：直接定义各个英雄类

- 战士类：
  - 属性：昵称，等级，最大生命值，当前生命值，物理攻击力。。。
  - 方法：移动，物理攻击，嘲讽。。。
- 法师类：
  - 属性：昵称，等级，最大生命值，当前生命值，法术攻击力。。。
  - 方法：移动，法术攻击，瞬移。。。

方案二：使用继承（inheritance）

优点：
- 基类定义公共内容，方便统一修改
  - 代码的可重用性：类库（不需要了解核心技术细节）
- 重定义基类的成员函数
- 添加新类，新成员（职业）方便

注意：
1. 派生类对象存储了基类的数据成员，即，派生类继承了基类的实现
2. 派生类对象可以调用基类的非私有函数
3. 派生类需要自己的构造函数，子类要自己定义自己的构造函数
4. 派生类可以根据需要添加额外的数据成员和函数

## 继承的c++实现（公有继承）

```c++
class Hero
{
private:
    string m_NickName;
    int m_Level;
    int m_MaxLife;
    int m_CurrLife;
public:
    Hero();
    void Move();
    //Getter Ana Setter...

class Warrior:public Hero//公有继承，建立一种 is a 关系，比如Warrior is a Hero
{
    //战士类特有的成员和函数
}
class Archmage:public Hero
{
    //法师类特有的成员和函数
}
class Assassin:public Hero
{
    //刺客类特有的成员和函数
}
}
```

## 继承下的c++对象模型-单继承1
没有继承时，成员变量和成员函数会分开存储：
1. 对象的内存中只包含成员变量，存储在栈区或堆区（使用new创建对象时）
2. 成员函数与对象内存分离，存储在代码区比如下面的代码
   1. Warrior * warrior1 = new Warrior();
   2. Warrior * warrior2 = new Warrior();
   3. Warrior * warrior3 = new Warrior();

1. 编译器会将成员变量和成员函数分开存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码
2. 类可以看做是一种复杂的数据类型，如果使用sizeof求类所占空间的大小，会发现，只是计算了成员变量的大小，并没有把成员函数也包含在内

## 继承下的c++对象模型=单继承2
有继承关系时的内存模型
1. 有继承关系时，派生类的内存模型可以看成是基类成员变量和新增成员变量的总和
2. 所有成员函数仍然存储在另外一个区域——代码区，由所有对象共享

## 有关基类，派生类构造
1. 实例化派生类对象时，首先会创建基类对象（调用基类构造）
2. 派生类构造应通过成员初始化列表将基类信息传递给基类构造
3. 应该在派生类构造中初始化派生类新增的数据成员

注意体会派生类及基类中存在同名函数时的调用问题

## 派生类与基类之间的特殊关系小结
派生类对象可以使用基类的非私有成员函数
```c++
Warrior warrior;
warrior.SetNickName("狂战士胖虎");
```
基类指针可以在不进行显式类型转换的情况下指向派生类对象
```c++
Warrior warrior("诸葛达摩",10,100,100,10000);
Hero & refHero = warrior;//如果使用基类引用指向派生类对象，那么基类引用就不能调用派生类中定义的方法了
Hero * ptrHero = &warrior;//基类指针也可以指向派生类对象，同样也是不能调用派生类方法

//如果想要使用派生类方法的话，就需要强转
//即父类引用/指针需要强转成子类引用/指针
Warrior& warrior2 = (Warrior&)refHero;//括号的内容为强转

refHero.Move();//基类引用调用函数
ptrHero->Move();//基类指针调用函数
```
可以将派生对象赋值给基类对象，程序将使用隐式重载赋值运算符
```c++
Hero hero = warrior;//基类引用指向的也是派生类对象
hero.Move();
```
不可以将基类对象和地址赋值给派生类引用和对象，即以上操作不能做逆操作

## 派生类成员的访问控制
1. 公有继承（public inheritance）
   
   基类的公有成员和受保护成员，在派生类中保持原来的访问属性，其私有成员仍为基类所独有
2. 私有继承（private inheritance）
   
   基类的公有成员和受保护成员，在派生类中成为了私有成员，私有成员仍为基类独有
3. 受保护继承（protected inheritance）
   
   基类公有成员和受保护成员，在派生类中成了受保护成员，私有成员仍为基类独有


| |公有继承|私有继承|保护继承|
|-|-|-|-|
|公有|公有|私有|受保护|
|受保护|受保护|私有|受保护|
|私有|不被继承|不被继承|不被继承|

注意：
1. 公有权限下，基类自己、派生类及外部都可以访问
2. 私有权限下，只能基类自己访问，派生类及外部都无法访问
3. 受保护权限下，基类自己和派生类可以访问，外部无法访问

##派生类成员的访问
继承方式提供给程序员对类进行封装的机制
- 全部继承，不封装基类，那么用公用继承，is-a关系
- 全部继承，完全封装基类，那么使用私有继承，
- 全部继承，有选择的封装基类，那么使用受保护继承，

这三种选择是程序员在开发中运用面向对象思想的重要体现
- 需要封装哪些成员变量和成员函数
- 需要把哪些成员函数作为接口来被调用

不管哪种继承，派生类都不能访问基类的私有成员（除非改成protected）

示例
```c++
class Emperor //皇帝父类
{
private:
  string[] bueaties;//后宫佳丽
  double silvers;//私房钱
protected:
  string palace; //宫殿名称
public:
  Emperor();
  ~Emperor();
  string reighTitle;//年号
}

//公有继承：
//继承后派生类的成员访问权限：（非实际代码）
// public成员保持不变，private成员不可见，protected成员也保持不变
// 派生类中没有，意味着访问不到，但是内存中是有的
class FourthSon:public Emperor//四皇子
{
protected:
  string palace;//宫殿名称
public:
  FourthSon();
  ~FourthSon();
  string reignTitle;//年号
}

//受保护的继承
//首先，私有的仍然是不可见的
// 原来的public变成了protected，原来的protected保持不变
// 年号和宫殿除了外人不能访问，自己、友元及子类都能访问
class ThirteenSon:protected Emperor
{
protected:
  string reignTitle;//年号
  string palace;//宫殿名称
public:
  ThirteenSon();
  ~ThirteenSon();
}

//私有继承
//通过private方式继承：public和protected都变成了private
class SecondSon:private Emperor //二皇子
{
private:
  string palace;//宫殿名称
  string reignTitle;//年号
public:
  SecondSon();
  ~SecondSon();
}
```
注意：请谨慎的使用私有继承
- 私有继承纯粹是一种实现技术，所以在软件的“设计”层面没有意义，只是在软件实现层面，能够使用私有继承向下隐藏实现细节
- 私有继承可以实现has-a关系，但是大多数程序员倾向于使用包含实现has-a关系，一是更加容易理解，二是继承特别是多继承会引起很多问题

## 继承与组合
在一个类中有另外一个类的对象作为数据成员，这种方式叫做类的组合形式
  - 通过继承建立了一个派生类与基类的关系，它是一种is-a “是”的关系
    - 比如，狗是哺乳动物、战士是英雄、橘猫是宠物
  - 类的组合关系，它们之间不是“是”的关系，而是“有”的关系
    - 比如，学生有书包、战士有武器、机枪有子弹、老板有小蜜
  - 继承一般是纵向的，而组合是横向的